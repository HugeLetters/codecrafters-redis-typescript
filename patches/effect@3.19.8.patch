diff --git a/node_modules/effect/.bun-tag-d37b1da431ee30b5 b/.bun-tag-d37b1da431ee30b5
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/dist/dts/Match.d.ts b/dist/dts/Match.d.ts
index 3f7e9d2ef7076ec7c6e5acbe7853b0e3b4ce543f..fed0282da3f9c9af98768583043a5eafda8541b8 100644
--- a/dist/dts/Match.d.ts
+++ b/dist/dts/Match.d.ts
@@ -1132,9 +1132,16 @@ export declare namespace Types {
     } & {};
     type ExtractAndNarrow<Input, P> = P extends Predicate.Refinement<infer _In, infer _Out> ? _Out extends Input ? Extract<_Out, Input> : Extract<Input, _Out> : P extends SafeRefinement<infer _In, infer _R> ? [0] extends [1 & _R] ? Input : _In extends Input ? Extract<_In, Input> : Extract<Input, _In> : P extends Predicate.Predicate<infer _In> ? Extract<Input, _In> : Input extends infer I ? Exclude<I extends ReadonlyArray<any> ? P extends ReadonlyArray<any> ? {
         readonly [K in keyof I]: K extends keyof P ? ExtractAndNarrow<I[K], P[K]> : I[K];
-    } extends infer R ? Fail extends R[keyof R] ? never : R : never : never : IsPlainObject<I> extends true ? string extends keyof I ? I extends P ? I : never : symbol extends keyof I ? I extends P ? I : never : Simplify<{
+    } extends infer R ? Fail extends R[keyof R] ? never : MapUnknown<P> extends MapUnknown<R> ? readonly [...ArrayRefinmentType<R, P>,...ReadonlyArray<I[number]>] : R : never : never : IsPlainObject<I> extends true ? string extends keyof I ? I extends P ? I : never : symbol extends keyof I ? I extends P ? I : never : Simplify<{
         [RK in Extract<keyof I, keyof P>]-?: ExtractAndNarrow<I[RK], P[RK]>;
     } & Omit<I, keyof P>> extends infer R ? keyof P extends NonFailKeys<R> ? R : never : never : MaybeReplace<I, P> extends infer R ? [I] extends [R] ? I : R : never, Fail> : never;
     type NonFailKeys<A> = keyof A & {} extends infer K ? K extends keyof A ? A[K] extends Fail ? never : K : never : never;
+    type ArrayRefinmentType<I, P> = {
+	    readonly [K in keyof P]: ExtractAndNarrow<I[K & keyof I], P[K]>;
+    };
+    type MapUnknown<P> = {
+	    readonly [K in keyof P]: unknown;
+    };
+
 }
 //# sourceMappingURL=Match.d.ts.map
\ No newline at end of file
diff --git a/dist/esm/SchemaAST.js b/dist/esm/SchemaAST.js
index cc41d9c000571686b9db88d679f0995c83f67a85..372e7561e55f29a1dddb83c94b43b6303bd40d4d 100644
--- a/dist/esm/SchemaAST.js
+++ b/dist/esm/SchemaAST.js
@@ -960,7 +960,11 @@ export class TemplateLiteral {
     };
   }
 }
-const formatTemplateLiteral = ast => "`" + ast.head + ast.spans.map(String).join("") + "`";
+function rawString(string) {
+  const formatted = Inspectable.formatUnknown(string);
+  return formatted.slice(1, formatted.length - 1);
+}
+const formatTemplateLiteral = ast => "`" + rawString(ast.head) + ast.spans.map(String).join("") + "`";
 /**
  * @category guards
  * @since 3.10.0
